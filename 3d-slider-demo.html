<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Scenes Slider</title>
    
    <!-- Обновленные версии библиотек -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@8/swiper-bundle.min.css" />
    
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #1a1a1a;
        color: #fff;
        font-family: Arial, sans-serif;
        overflow: hidden;  /* Предотвращаем прокрутку */
      }

      .swiper {
        width: 100%;
        height: 100vh;  /* Используем полную высоту экрана */
      }
      
      .swiper-slide {
        background: #1a1a1a;
      }
      
      .three-scene {
        width: 100%;
        height: 100%;
        position: relative;
      }

      /* Делаем кнопки навигации более заметными */
      .swiper-button-next,
      .swiper-button-prev {
        color: #31baeb;
        background: rgba(0, 0, 0, 0.5);
        padding: 30px;
        border-radius: 50%;
      }

      .swiper-pagination-bullet {
        background: #31baeb;
      }

      .model-info {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <div class="swiper">
      <div class="swiper-wrapper">
        <div class="swiper-slide">
          <div class="three-scene" id="scene1"></div>
          <div class="model-info">
            <h3>Сцена 1</h3>
            <p>Интерактивный куб с освещением</p>
          </div>
        </div>
        <div class="swiper-slide">
          <div class="three-scene" id="scene2"></div>
          <div class="model-info">
            <h3>Сцена 2</h3>
            <p>Сфера с динамическим освещением</p>
          </div>
        </div>
        <div class="swiper-slide">
          <div class="three-scene" id="scene3"></div>
          <div class="model-info">
            <h3>Сцена 3</h3>
            <p>Тороид с отражениями</p>
          </div>
        </div>
      </div>
      <div class="swiper-pagination"></div>
      <div class="swiper-button-prev"></div>
      <div class="swiper-button-next"></div>
    </div>

    <!-- Обновленные версии скриптов -->
    <script src="https://cdn.jsdelivr.net/npm/swiper@8/swiper-bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.150.1/three.min.js"></script>
    
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Инициализация Swiper
        const swiper = new Swiper('.swiper', {
          loop: true,
          speed: 1000,
          effect: 'fade',
          fadeEffect: {
            crossFade: true
          },
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });

        // Массив для хранения сцен
        const scenes = [];

        // Функция для создания базовой сцены
        function createBaseScene(element) {
          const scene = new THREE.Scene();
          scene.background = new THREE.Color(0x1a1a1a);
          
          const camera = new THREE.PerspectiveCamera(
            75,
            element.clientWidth / element.clientHeight,
            0.1,
            1000
          );
          camera.position.z = 5;

          const renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(element.clientWidth, element.clientHeight);
          renderer.setPixelRatio(window.devicePixelRatio);
          element.appendChild(renderer.domElement);

          // Освещение
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
          scene.add(ambientLight);

          const pointLight = new THREE.PointLight(0xffffff, 1);
          pointLight.position.set(5, 5, 5);
          scene.add(pointLight);

          return { scene, camera, renderer };
        }

        // Создание различных геометрий для каждой сцены
        function createGeometry(index) {
          switch(index) {
            case 0:
              return new THREE.BoxGeometry(2, 2, 2);
            case 1:
              return new THREE.SphereGeometry(1.5, 32, 32);
            case 2:
              return new THREE.TorusGeometry(1.5, 0.5, 16, 100);
            default:
              return new THREE.BoxGeometry(1, 1, 1);
          }
        }

        // Создание материалов для каждой сцены
        function createMaterial(index) {
          const colors = [0x31baeb, 0x31eb7d, 0xeb3173];
          return new THREE.MeshPhongMaterial({
            color: colors[index],
            shininess: 100,
            specular: 0xffffff
          });
        }

        // Создаем сцены
        document.querySelectorAll('.three-scene').forEach((element, index) => {
          const { scene, camera, renderer } = createBaseScene(element);
          
          // Создаем объект
          const geometry = createGeometry(index);
          const material = createMaterial(index);
          const mesh = new THREE.Mesh(geometry, material);
          scene.add(mesh);

          // Сохраняем объект сцены
          const sceneObj = {
            scene,
            camera,
            renderer,
            mesh,
            animate: function() {
              if (swiper.activeIndex === index) {
                this.mesh.rotation.x += 0.01;
                this.mesh.rotation.y += 0.01;
                this.renderer.render(this.scene, this.camera);
              }
            }
          };

          scenes.push(sceneObj);

          // Добавляем интерактивность
          element.addEventListener('mousemove', (event) => {
            if (swiper.activeIndex === index) {
              const rect = element.getBoundingClientRect();
              const x = ((event.clientX - rect.left) / element.clientWidth) * 2 - 1;
              const y = -((event.clientY - rect.top) / element.clientHeight) * 2 + 1;
              
              mesh.rotation.y = x * Math.PI;
              mesh.rotation.x = y * Math.PI;
            }
          });
        });

        // Анимационный цикл
        function animate() {
          requestAnimationFrame(animate);
          scenes.forEach(scene => scene.animate());
        }
        animate();

        // Обработка изменения размера окна
        window.addEventListener('resize', function() {
          scenes.forEach(scene => {
            const element = scene.renderer.domElement.parentElement;
            const width = element.clientWidth;
            const height = element.clientHeight;
            
            scene.camera.aspect = width / height;
            scene.camera.updateProjectionMatrix();
            scene.renderer.setSize(width, height);
          });
        });

        // Обновляем размер при инициализации
        window.dispatchEvent(new Event('resize'));
      });
    </script>
  </body>
</html>